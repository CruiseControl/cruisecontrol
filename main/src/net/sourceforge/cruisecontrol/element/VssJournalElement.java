/********************************************************************************
 * CruiseControl, a Continuous Integration Toolkit
 * Copyright (c) 2001, ThoughtWorks, Inc.
 * 651 W Washington Ave. Suite 500
 * Chicago, IL 60661 USA
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 *     + Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *
 *     + Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimer in the documentation and/or other materials provided
 *       with the distribution.
 *
 *     + Neither the name of ThoughtWorks, Inc., CruiseControl, nor the
 *       names of its contributors may be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 ********************************************************************************/
package net.sourceforge.cruisecontrol.element;

import java.io.*;
import java.text.*;

import java.util.*;
import net.sourceforge.cruisecontrol.Modification;

import org.apache.tools.ant.Task;

/**
 *  This class handles all VSS-related aspects of determining the modifications
 *  since the last good build.
 *
 *  This class uses Source Safe Journal files.  Unlike the history files
 *  that are generated by executing <code>ss.exe history</code>, journal
 *  files must be setup by the Source Safe administrator before the point
 *  that logging of modifications is to occur.
 *
 *  This code has been tested against Visual Source Safe v6.0 build 8383.
 *
 *  @author Eli Tucker
 *  @author <a href="mailto:alden@thoughtworks.com">alden almagro</a>
 *  @author <a href="mailto:jcyip@thoughtworks.com">Jason Yip</a>
 *  @author Arun Aggarwal
 */
public class VssJournalElement extends SourceControlElement {
    
    public static final SimpleDateFormat VSS_OUT_FORMAT = 
        new SimpleDateFormat("'Date: 'MM/dd/yy  'Time: 'hh:mma");
    
    private String _ssDir = "$/";
    private String _journalFile;
    private String _property;
    private String _propertyOnDelete;
    
    private long _lastModified;
    private Date _lastBuild;
    
    private ArrayList _modifications = new ArrayList();
    private Set _emails = new HashSet();
    
    /**
     *  Set the project to get history from
     *
     *  @param  s
     */
    public void setSsDir(String s) {
        _ssDir = "$" + s;
    }
    
    /**
     *  Full path to journal file.  Example: <code>c:/vssdata/journal/journal.txt</code>
     *
     *  @param s
     */
    public void setJournalFile(String s) {
        _journalFile = s;
    }
    
    /**
     *  Choose a property to be set if the project has modifications if we have a
     *  change that only requires repackaging, i.e. jsp, we don't need to recompile
     *  everything, just rejar.
     *
     *@param  s
     */
    public void setProperty(String s) {
        _property = s;
    }
    
    public void setPropertyOnDelete(String s) {
        _propertyOnDelete = s;
    }
    
    /**
     *  Sets the _lastBuild date. Protected so it can be used by tests.
     */
    protected void setLastBuildDate(Date lastBuild) {
        _lastBuild = lastBuild;
    }
    
    /**
     *  For parent modificationset to find out the time of last modification for
     *  this project
     *
     *  @return
     */
    public long getLastModified() {
        return _lastModified;
    }
    
    /**
     *  Returns a Set of usernames that made any modification since the last good
     *  build.
     *
     *  @return
     */
    public Set getEmails() {
        return _emails;
    }
    
    /**
     *  Returns a List of modifications to this project since the last good
     *  build.
     *
     *  @return
     */
    public List getModifications() {
        return _modifications;
    }
    
    /**
     *  Do the work... I'm writing to a file since VSS will start wrapping lines
     * if I read directly from the stream.
     *
     *@param  lastBuild
     *@param  now
     *@param  quietPeriod
     *@return
     */
    public List getHistory(Date lastBuild, Date now, long quietPeriod) {
        _lastBuild = lastBuild;
        
        try {
            BufferedReader br = new BufferedReader(new FileReader(_journalFile));
            
            String s = br.readLine();
            while (s != null) {
                ArrayList entry = new ArrayList();
                entry.add(s);
                s = br.readLine();
                while (s != null && !s.equals("")) {
                    entry.add(s);
                    s = br.readLine();
                }
                handleEntry(entry);
                if(s.equals("")) {
                    s = br.readLine();
                }
            }
            
            br.close();
            
        } catch (Exception e) {
            e.printStackTrace();
        }
        
        if (_property != null && _modifications.size() > 0) {
            getAntTask().getProject().setProperty(_property, "true");
        }
        
        return _modifications;
    }
    
    /**
     *  pretty logging
     *
     *@param  mod
     */
    private void logModification(Modification mod) {
        log("Type: " + mod.type + " " + mod.fileName);
        log("User: " + mod.userName + " Date: " + mod.modifiedTime);
        log("");
    }
    
    /**
     *  Parse individual VSS history entry
     *
     *@param  historyEntry
     */
    protected void handleEntry(List historyEntry) {
        
        Modification mod = new Modification();
        String nameAndDateLine = (String) historyEntry.get(2);
        mod.userName = parseUser(nameAndDateLine);
        mod.modifiedTime = parseDate(nameAndDateLine);
        
        String folderLine = (String) historyEntry.get(0);
        String fileLine = (String) historyEntry.get(3);
        
        if(!isInSsDir(folderLine)) {
            // We are only interested in modifications to files in the specified ssdir
            return;
        } else if (isBeforeLastBuild(mod.modifiedTime)) {
            // We are only interested in modifications since the last build
            return;
        } else if (fileLine.startsWith("Labeled")) {
            // We don't add labels.
            return;
        } else if (fileLine.startsWith("Checked in")) {
            mod.type = "checkin";
            mod.comment = parseComment(historyEntry);
            mod.fileName = substringFromLastSlash(folderLine);
            mod.folderName = substringToLastSlash(folderLine);
        } else if (fileLine.indexOf(" renamed to ") > -1) {
            // TODO: This is a special case that is really two modifications: deleted and recovered.
            //       For now I'll consider it a deleted to force a clean build.
            //       I should really make this two modifications.
            mod.type = "delete";
            mod.comment = parseComment(historyEntry);
            mod.fileName = fileLine.substring(0, fileLine.indexOf(" "));
            mod.folderName = folderLine;
        } else if (fileLine.indexOf(" moved to ") > -1) {
            // TODO: This is a special case that is really two modifications: deleted and recovered.
            //       For now I'll consider it a deleted to force a clean build.
            //       I should really make this two modifications.
            mod.type = "delete";
            mod.comment = parseComment(historyEntry);
            mod.fileName = fileLine.substring(0, fileLine.indexOf(" "));
            mod.folderName = folderLine;
        } else {
            mod.folderName = folderLine;
            mod.fileName = fileLine.substring(0, fileLine.lastIndexOf(" "));
            mod.comment = parseComment(historyEntry);
            
            if (fileLine.endsWith("added")) {
                mod.type = "add";
            } else if (fileLine.endsWith("deleted")) {
                mod.type = "delete";
            } else if (fileLine.endsWith("recovered")) {
                mod.type = "recover";
            } else if (fileLine.endsWith("shared")) {
                mod.type = "branch";
            }
        }
        
        if (_propertyOnDelete != null && "delete".equals(mod.type)) {
            getAntTask().getProject().setProperty(_propertyOnDelete, "true");
        }
        
        if (_property != null) {
            getAntTask().getProject().setProperty(_property, "true");
        }
        
        // Add the modification and the user's email
        _modifications.add(mod);
        _emails.add(mod.userName);
        logModification(mod);
    }
    
    /**
     *  parse comment from vss history (could be multiline)
     *
     *@param  a
     *@return
     */
    private String parseComment(List a) {
        StringBuffer comment = new StringBuffer();
        if(a.size() > 4) {
            comment.append(((String) a.get(4)) + " ");
            for (int i = 5; i < a.size(); i++) {
                comment.append(((String) a.get(i)) + " ");
            }
        }
        return comment.toString().trim();
    }
    
    /**
     * Parse date/time from VSS file history
     *
     * The nameAndDateLine will look like
     *  User: Etucker      Date:  6/26/01   Time: 11:53a
     * Sometimes also this
     *  User: Aaggarwa     Date:  6/29/:1   Time:  3:40p
     * Note the ":" instead of a "0"
     *
     *@param  dateLine
     *@return Date in form "'Date: 'MM/dd/yy   'Time:  'hh:mma"
     */
    public Date parseDate(String nameAndDateLine) {
        String dateAndTime = nameAndDateLine.substring(nameAndDateLine.indexOf("Date: "));
        
        int indexOfColon = dateAndTime.indexOf("/:");
        if(indexOfColon != -1) {
            dateAndTime = dateAndTime.substring(0, indexOfColon)
            + dateAndTime.substring(indexOfColon, indexOfColon + 2).replace(':','0')
            + dateAndTime.substring(indexOfColon + 2);
        }
        
        try {
            Date lastModifiedDate = VSS_OUT_FORMAT.parse(dateAndTime.trim() + "m");
            
            //(PENDING) This seems out of place
            if (lastModifiedDate.getTime() < _lastModified) {
                _lastModified = lastModifiedDate.getTime();
            }
            
            return lastModifiedDate;
        } catch (ParseException pe) {
            pe.printStackTrace();
            return null;
        }
    }
    
    /**
     *  Parse username from VSS file history
     *
     *@param  userLine
     *@return the user name who made the modification
     */
    public String parseUser(String userLine) {
        final int START_OF_USER_NAME = 6;
        try {
            String userName = userLine.substring(
            START_OF_USER_NAME, userLine.indexOf("Date: ") - 1).trim();
            
            return userName;
        } catch (StringIndexOutOfBoundsException e) {
            System.err.println("Unparsable string was: " + userLine);
            throw e;
        }
        
    }
    
    /**
     *  Returns the substring of the given string from the last "/" character.
     *  UNLESS the last slash character is the last character or the string
     *  does not contain a slash.  In that case, return the whole string.
     */
    public String substringFromLastSlash(String input) {
        int lastSlashPos = input.lastIndexOf("/");
        if (lastSlashPos > 0 && lastSlashPos+1 <= input.length()) {
            return input.substring(lastSlashPos + 1);
        } else {
            return input;
        }
    }
    
    /**
     *  Returns the substring of the given string from the beginning to the last "/" character
     *  or till the end of the string if no slash character exists.
     */
    public String substringToLastSlash(String input) {
        int lastSlashPos = input.lastIndexOf("/");
        if (lastSlashPos > 0) {
            return input.substring(0, lastSlashPos);
        } else {
            return input;
        }
    }
    
    /**
     *  Determines if the given folder is in the ssdir specified for this VssJournalElement.
     */
    protected boolean isInSsDir(String path) {
        if (path.toLowerCase().indexOf(_ssDir.toLowerCase()) == 0) {
            return true;
        } else {
            return false;
        }
    }
    
    /**
     *  Determines if the date given is before the last build for this VssJournalElement.
     */
    protected boolean isBeforeLastBuild(Date date) {
        return date.before(_lastBuild);
    }
    
}
