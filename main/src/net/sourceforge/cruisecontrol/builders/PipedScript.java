package net.sourceforge.cruisecontrol.builders;

import java.io.InputStream;
import java.util.Collection;
import java.util.Map;
import java.util.regex.Pattern;

import org.apache.commons.lang.StringUtils;
import org.jdom2.Element;

import net.sourceforge.cruisecontrol.Builder;
import net.sourceforge.cruisecontrol.CruiseControlException;
import net.sourceforge.cruisecontrol.Progress;
import net.sourceforge.cruisecontrol.gendoc.annotations.SkipDoc;
import net.sourceforge.cruisecontrol.util.OSEnvironment;

/**
 * The interface which commands run within {@link PipedExecBuilder} must implement.
 */
public interface PipedScript extends Runnable {

    /**
     * Embedded interface to merge local environment variable settings with the variable settings of the
     * parent builder.
     */
    interface EnvGlue {
        /** The same action as implemented by {@link Builder#mergeEnv(OSEnvironment)} */
        void mergeEnv(final OSEnvironment env);
    }


    /**
     * Validates the object (checks if all the attributes are set and correct)
     * @throws CruiseControlException
     */
    void validate() throws CruiseControlException;

    /**
     * Object initialisation method - it is supposed to prepare the script for running. It is
     * ensured that the method will only be called when {@link #validate()} will pass and
     * before {@link #run()} is called. However, it can be called repeatedly for the object.
     */
    void initialize() throws CruiseControlException;
    /**
     * Object finishing method - it must be supposed to clean the script internal variables (to save a
     * memory) after running. It is ensured that the method will only be called after {@link #run()} is
     * done (i.e. {@link #isDone()} reports <code>true</code>), and no other method of the script will
     * be called except the new {@link #initialize()} initialization.
     */
    void finish() throws CruiseControlException;

    /**
     * The {@link Runnable#run()} method. It is ensured that the method will only be called after
     * {@link #initialize()} method. It can be called repeatedly for the object (every time preceded
     * by the call of {@link #initialize()}, however).
     */
    @Override
    void run();

    /**
     * Sets the ID of the script from <code>id=""</code> attribute in XML configuration
     * (referenced by <code>pipefrom=""</code> and <code>waitfor=""</code>). Required.
     * Each script must have <b>unique</b> ID assigned.
     *
     * @param value ID of the script.
     */
    void setID(String value);

    /**
     * Gets the ID of the script set by {@link #setID(String)}, or <code>null</code> if not
     * set yet.
     *
     * @return the ID of the script.
     */
    String getID();

    /**
     * Sets the IDs of the script from <code>pipefrom=""</code> attribute in XML
     * configuration. The STDIN of the current script is read from STDOUT of the script with
     * ID set. The attribute is optional if it is not required to read input from another
     * script.
     *
     * @param value ID of the script to read input from, or a comma-separated list of IDs
     */
    void setPipeFrom(String value);
    /**
     * Gets the list of IDs of the script set by {@link #setPipeFrom(String)}, or empty list
     * if not set yet.
     *
     * @return the list of ID's of the script to read input from.
     */
    String[] getPipeFrom();

    /**
     * Sets the IDs of the script from <code>waitfor=""</code> attribute in XML configuration.
     * The execution of the current script will be delayed until all the scripts with given IDs are
     * completed - it is aimed to prevent consecutive run of commands which consume large
     * amount of memory, or to wait for file(s) generated by another script (not the data
     * passed through STDIO). The attribute is optional
     *
     * @param value ID of the script to wait for, or comma-separated list of IDs.
     */
    void setWaitFor(String value);
    /**
     * Gets the list of IDs of the script set by {@link #setWaitFor(String)}, or empty list
     * if not set yet.
     *
     * @return the list of IDs the script must wait for.
     */
    String[] getWaitFor();

    /**
     * Sets the XML element into which the build log returned by
     * {@link net.sourceforge.cruisecontrol.Builder#build(Map, Progress)}, when called in {@link #run()},
     * is required to be stored.
     *
     * @param buildLogParent the required parent of build log element.
     * @see net.sourceforge.cruisecontrol.Builder#build(Map, Progress)
     */
    @SkipDoc
    void setBuildLogParent(Element buildLogParent);

    /**
     * Sets the map of build properties passed to the
     * {@link net.sourceforge.cruisecontrol.Builder#build(Map, Progress)} when called in {@link #run()}.
     *
     * @param buildProperties build properties, may be <code>null</code>.
     * @see net.sourceforge.cruisecontrol.Builder#build(Map, Progress)
     */
    @SkipDoc
    void setBuildProperties(final Map<String, String> buildProperties);

    /**
     * Sets the callback to provide progress updates, passed to the
     * {@link net.sourceforge.cruisecontrol.Builder#build(Map, Progress)} when called in {@link #run()}.
     *
     * @param progress callback to provide progress updates, may be <code>null</code>.
     * @see net.sourceforge.cruisecontrol.Builder#build(Map, Progress)
     */
    @SkipDoc
    void setProgress(final Progress progress);

    /**
     * Sets the stream to read input of the script from.
     *
     * @param input the stream to read input from
     * @param id the ID of script the stream was filled by (must be one of {@link #getPipeFrom()} 
     * @throws CruiseControlException in case of an unexpected input provider
     */
    @SkipDoc
    void setInputProvider(final InputStream input, final String id) throws CruiseControlException;

    /**
     * Sets the environment variables glue object.
     * @param env the glue object
     */
    @SkipDoc
    void setEnvGlue(final EnvGlue env);

    /**
     * Returns the stream from which the output of the script can be read.
     * The output data of the script is buffered, so the method can be called multiple times,
     * each time new stream reading data from the beginning is returned.
     *
     * @return the stream from which to read the output of the script.
     */
    InputStream getOutputReader();

    /**
     * @return <code>true</code> when the script finished its work and <code>false</code>
     *          when it is running or has not been started yet.
     */
    boolean isDone();

    /**
     * Sets the directory in which the script will be running (all non-absolute the paths in the
     * script's configuration are tried relative to this directory.
     *
     * @param workingDir the path to the directory (if not absolute, first is tried relative to the
     *      current CC working directory is tried, than relative to CC's home directory.
     */
    void setWorkingDir(String workingDir);
    /**
     * @return the value set through {@link #setWorkingDir(String)} method, or <code>null</code>
     *      if not set.
     */
    String getWorkingDir();

    /**
     * Should the output of scripts be kept gzipped within the builder?
     * See {@link PipedExecBuilder#setGZipStdout(boolean)} for more details.
     *
     * @param gzip <code>true</code> if script's output is required to be stored gzipped,
     *   <code>false</code> if raw output content is kept.
     */
    void setGZipStdout(boolean gzip);
    /**
     * @return <code>null</code> if not set otherwise by {@link #setGZipStdout(boolean)}.
     */
    Boolean getGZipStdout();

    /**
     * Is the output content of the script in binary form?
     * See {@link PipedExecBuilder#setBinaryStdout(boolean)} for more details.
     *
     * @param binary <code>true</code> if script's output is in binary form, <code>false</code>
     *   if STDOUT is text.
     */
    void setBinaryOutput(boolean binary);
    /**
     * @return <code>null</code> if not set otherwise by {@link #setBinaryOutput(boolean)}.
     */
    Boolean getBinaryOutput();

    /**
     * Sets the amount of time [in secs] which may by consumed by during the running of the script.
     * The the timeout is passed, the script may be killed by CC.
     *
     * @param time the timeout value
     */
    void setTimeout(long time);
    /**
     * @return {@link ScriptRunner#NO_TIMEOUT} of the value set by {@link #setTimeout(long)}
     */
    long getTimeout();


    /**
     * Inner class with few helpers for the {@link PipedScript} interface.
     */
    public static final class Helpers {

        /** Joins the collection of strings to be accepted by {@link PipedScript#setPipeFrom(String)}
         *  and/or {@link PipedScript#setWaitFor(String)}.
         *
         *  @param s the collection to join
         *  @return the comma-separated items from the input collection
         */
        public static String join(final Collection<String> s) {
            return s != null ? StringUtils.join(s.iterator(), ",") : "";
        }
        public static String join(final String[] s) {
            return s != null ? StringUtils.join(s, ",") : "";
        }
        /** Splits the string to the array according to the ',' separator. It is, in particular, helpful
         *  for {@link PipedScript#setPipeFrom(String)} to {@link PipedScript#getPipeFrom()} and/or
         *  {@link PipedScript#setWaitFor(String)} to {@link PipedScript#getWaitFor()} conversion.
         *
         *  @param s the string to split
         *  @return the collection of items from the input string
         */
        public static String[] split(final String s) {
            return s != null && s.length() > 0 ? SPLIT.split(s) : new String[0];
        }

        /* Hide */
        private Helpers() { //not called
        }

        /** Split operator used in {@link #split(String)} */
        private static final Pattern SPLIT = Pattern.compile("[ ]*[,][ ]*");
    }
}
