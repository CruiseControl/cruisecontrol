Suppose that all the scripts read data either from input file (option -i), or from STDIN if no file is given. Also suppose that they write output into file (option -o) or into STDOUT if no file is given.
<ol>
    <li> Invoke piped exec builder, specifying the working directory as <code>/workspace/myproject</code> using property substitution and executing the sequence of Perl scripts <code>first.pl -i data.txt | second.pl -o result.txt</code>.

         <pre>&lt;schedule&gt;
    &lt;pipedexec workingdir="/workspace/${projectname}"&gt;
        &lt;exec id="1"
             command="/usr/local/bin/Perl"
             args="first.pl -i data.txt" /&gt;
        &lt;exec id="2"
             pipefrom="1"
             command="/usr/local/bin/Perl"
             args="second.pl -o result.txt" /&gt;
    &lt;/pipedexec&gt;
&lt;/schedule&gt;</pre>
    </li>

    <li>Invoke piped exec builder, specifying another working directory for the last script, and an independent timeout for the first script. An error in the first script is signaled by an <code>error occurred</code> message instead of the script's return error code. The sequence is now <code>first.pl -i data.txt | tee >(second.pl -o result.txt) | third.pl -o result.txt</code>.

         <pre>&lt;schedule&gt;
    &lt;pipedexec workingdir="/workspace/${projectname}"&gt;
        timeout="60"
        &lt;exec id="1"
             command="/usr/local/bin/Perl"
             args="first.pl -i data.txt" /&gt;
             timeout="10" /&gt;
             errorstr="error occurred" /&gt;
        &lt;exec id="2"
             pipefrom="1"
             command="/usr/local/bin/Perl"
             args="second.pl -o results.txt" /&gt;
        &lt;exec id="3"
             pipefrom="1"
             command="/usr/local/bin/Perl"
             args="third.pl -o result.txt"
             workingdir="/distribution/${projectname}" /&gt;
    &lt;/pipedexec&gt;
&lt;/schedule&gt;</pre>
         </li>

      <li>Invoke more complicated piped exec builder, where 5th script required data generated by 2nd and 4th scripts, and 6th script requires data generated by 2th and 5th script. Therefore, scripts must wait for each other.

         <pre>&lt;schedule&gt;
    &lt;pipedexec workingdir="/workspace/${projectname}"&gt;
        &lt;exec id="1"
             command="/usr/local/bin/Perl"
             args="first.pl -i data.txt" /&gt;
        &lt;exec id="2"
             pipefrom="1"
             command="/usr/local/bin/Perl"
             args="second.pl" /&gt;
        &lt;exec id="3"
             pipefrom="2"
             command="/usr/local/bin/Perl"
             args="third.pl" /&gt;
        &lt;exec id="4"
             pipefrom="3"
             command="/usr/local/bin/Perl"
             args="fourth.pl -o 4out.txt" /&gt;
        &lt;!-- must not start until 4out.txt is ready. Without 'waitfor' it would be started
             before 4 is finished! --&gt;
        &lt;exec id="5"
             pipefrom="2"
             waitfor="4"
             command="/usr/local/bin/Perl"
             args="fiveth.pl -e 4out.txt -o 5out.txt" /&gt;
        &lt;!-- The same here --&gt;
        &lt;exec id="6"
             pipefrom="2"
             waitfor="5"
             command="/usr/local/bin/Perl"
             args="sixth.pl -e 5out.txt" /&gt;
        &lt;exec id="7"
             pipefrom="6"
             command="/usr/local/bin/Perl"
             args="seventh.pl -o results.txt" /&gt;
    &lt;/pipedexec&gt;
&lt;/schedule&gt;</pre>
      </li>
</ol>
